<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../../stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../../stylesheets/print.css" media="print" />
	<script type="text/javascript" src="../../javascripts/syntaxhighlighter/scripts/shCore.js"></script>
	<script type="text/javascript" src="../../javascripts/syntaxhighlighter/scripts/shBrushJScript.js"></script>
	<link type="text/css" rel="stylesheet" href="../../javascripts/syntaxhighlighter/styles/shCoreDefault.css"/>
	<script type="text/javascript">SyntaxHighlighter.all();</script>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>蛋疼鬼扯的算法问题</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h2>几个网上看到的面试题的个人解法.</h2>
		<font color="#000000"><h3>Post @ 2014-03-21</h3></font>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
<ul>
<li><h3>题目1：在排序数组中找出和为给定数值的两个数</h3></li>
<p>&nbsp; &nbsp; 比如给一个数组: 1 2 4 7 11 15 , 给定的数值为15, 那么 4 + 11 = 15, 输出4, 11 这对数字. 要求为O(n)复杂度</p>
<p>&nbsp; &nbsp;<strong>个人解法: 开始我们最先想到的肯定是用两个循环，一次比较当前一个和下一个,可是这样的算法复杂度变成了O(n<sup>2</sup>),并不符合要求。于是我想到了一个方法，用Hash表，把每个数字的值存在一个很长的数组里，我定义为65535, 每个数字的值就是它对应的索引，这样，从左往右扫描数组，我用给出的值减去当前的值，所得为差值，意思也就是如果这个数字满足成对的条件，那么它的差值必然存在于这个数组中，假设我扫描到4, 15 - 4 = 11, 那么如果4要成为满足条件的一对，11必然要存在这个数组中。接下来用Hash表去搜索这个差值是否存在于这个数组中，假如存在，输出这两个，将两个数字都清零, 避免输出4, 11 和 11, 4 这样的重复序列. 看代码.</strong></p>

<p><strong><u>PS：比较古怪的是，里面用到了负索引，居然也能成功，真是吃惊，虽然知道-1这样的索引表示前面一个，但是-1000这些都能正确输出，我猜想是不是编译器做了些技巧，假如我存放这样的数字A[-1002]编译器自动把它计算放到某个位置去了。使得A[-1002]居然也能正确访问，真是奇怪，不过我还是不推荐使用这样的方法，数字大了就会引发Segmetation Fault.所以这并不是一种安全可靠的办法.</u></strong></p>
<pre class="brush:js;">

#include <stdio.h>

#define MAXARRLEN 65535

int main (int argc, char *argv[])
{
	int n, i, sum, p = 0;
	int a[MAXARRLEN] = { 0 };
	int b[MAXARRLEN] = { 0 };
	sum = atoi (argv[argc - 1]);	
	for (i = 1; i < argc - 1; i++)
	  {
	    n = atoi (argv[i]);
	    a[p++] = n;
	    b[n]   = n;
	  }
	/* Start algorithm Stupid Hash*/
	/* Why the index of array become negative that the result is OK? */
	/* Eg, -10002, 8 10010 */
	/* error -65524 65532 8 */
	for (i = 0; i < p; i++)
	  {
	    if ((b[ sum-a[i] ] + a[i]) == sum)
	      {
	        printf ("%d--->%d\n", a[i], b[ sum-a[i] ]);
	        b[ a[i] ] = 0;
		b[ sum-a[i] ] = 0;
	      }
	  }
	return 0;
}
</pre>
<li><h3>结果如下, 最后的数字就是给定的数值</h3></li>
<img src="../images/outsn2.png" alt="输出和满足条件的两个数字">
</br>

<li><h3>题目2:

</ul>


  </section>

        <aside id="sidebar">
<a href="../../article/b.c_codes/2014-03-19-Count-appearances-of-digit-whin-given-number.html"  class="button">
            <small>上一篇</small>
          </a>
<a href="../../404.html"  class="button">
            <small>下一篇</small>
          </a>

        </aside>
      </div>
    </div>

  
  </body>
</html>
