<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../../stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../../stylesheets/print.css" media="print" />
	<script type="text/javascript" src="../../javascripts/syntaxhighlighter/scripts/shCore.js"></script>
	<script type="text/javascript" src="../../javascripts/syntaxhighlighter/scripts/shBrushJScript.js"></script>
	<link type="text/css" rel="stylesheet" href="../../javascripts/syntaxhighlighter/styles/shCoreDefault.css"/>
	<script type="text/javascript">SyntaxHighlighter.all();</script>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>蛋疼鬼扯的算法问题</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h2>几个网上看到的面试题的个人解法.</h2>
		<font color="#000000"><h3>Post @ 2014-03-21</h3></font>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
<ul>
<li><h3>题目1：在排序数组中找出和为给定数值的两个数</h3></li>
<p>&nbsp; &nbsp; 比如给一个数组: 1 2 4 7 11 15 , 给定的数值为15, 那么 4 + 11 = 15, 输出4, 11 这对数字. 要求为O(n)复杂度</p>
<p>&nbsp; &nbsp;<strong>个人解法: 开始我们最先想到的肯定是用两个循环，一次比较当前一个和下一个,可是这样的算法复杂度变成了O(n<sup>2</sup>),并不符合要求。于是我想到了一个方法，用Hash表，把每个数字的值存在一个很长的数组里，我定义为65535, 每个数字的值就是它对应的索引，这样，从左往右扫描数组，我用给出的值减去当前的值，所得为差值，意思也就是如果这个数字满足成对的条件，那么它的差值必然存在于这个数组中，假设我扫描到4, 15 - 4 = 11, 那么如果4要成为满足条件的一对，11必然要存在这个数组中。接下来用Hash表去搜索这个差值是否存在于这个数组中，假如存在，输出这两个，将两个数字都清零, 避免输出4, 11 和 11, 4 这样的重复序列. 看代码.</strong></p>

<p><strong><u>PS：比较古怪的是，里面用到了负索引，居然也能成功，真是吃惊，虽然知道-1这样的索引表示前面一个，但是-1000这些都能正确输出，我猜想是不是编译器做了些技巧，假如我存放这样的数字A[-1002]编译器自动把它计算放到某个位置去了。使得A[-1002]居然也能正确访问，真是奇怪，不过我还是不推荐使用这样的方法，数字大了就会引发Segmetation Fault.所以这并不是一种安全可靠的办法.</u></strong></p>
<pre class="brush:js;">

#include <stdio.h>

#define MAXARRLEN 65535

int main (int argc, char *argv[])
{
	int n, i, sum, p = 0;
	int a[MAXARRLEN] = { 0 };
	int b[MAXARRLEN] = { 0 };
	sum = atoi (argv[argc - 1]);	
	for (i = 1; i < argc - 1; i++)
	  {
	    n = atoi (argv[i]);
	    a[p++] = n;
	    b[n]   = n;
	  }
	/* Start algorithm Stupid Hash*/
	/* Why the index of array become negative that the result is OK? */
	/* Eg, -10002, 8 10010 */
	/* error -65524 65532 8 */
	for (i = 0; i < p; i++)
	  {
	    if ((b[ sum-a[i] ] + a[i]) == sum)
	      {
	        printf ("%d--->%d\n", a[i], b[ sum-a[i] ]);
	        b[ a[i] ] = 0;
		b[ sum-a[i] ] = 0;
	      }
	  }
	return 0;
}
</pre>
<li><h3>结果如下, 最后的数字就是给定的数值</h3></li>
<img src="../images/outsn2.png" alt="输出和满足条件的两个数字">
</br>

<li><h3>题目2:反转一个字符串，Python && C </h3></li>
<p> &nbsp;&nbsp; 将一个字符串按单词顺序翻转输出。比如输入: I am a student. --> studen. a am I. 这个是最让我无语的一个，原因是我在用C的是有装逼了，用了K&R C上面的代码，结果出问题了，然后就对着代码看啊想啊，没结果，无奈了，最后拿起GDB来开刀了，才知道自己装逼的下场，我本来是想给字符串赋值, 结果却把自己要保存的字符串全部给截断了，用的0. 用了这样的语句: <u>while ((*s++ = *t++) != '\0');</u>
这句在复制字符串的时候没问题，而且也很简洁， 先赋值再判断，如果*t == 0; 那么， *s的值也已经有了'\0'了,但是这并不是我的程序所期望的，我是用GDB调试的时候，才发现，每次都是复制完最后一个单词后，s串就被截断了，于是把程序改了一下: </p>
<pre class="brush:js;">
	while (*t)
	  {
		*s++ = *t++;
	  }
</pre>
 <p>这个和上面的那句最大的不同就是当到了 *t == '\0'的时候，前面的代码能保证*s也能获得'\0', 后面的就不会.也就是这个问题折腾了我好久.<strong>总结: 当出现问题后，在排除代码的逻辑错误之后，问题还是没搞定，那别犹豫了，拿起GDB吧。</strong> </p>
 <li><h3>第一个版本的代码，简直无法直视:</h3></li>
<pre class="brush: js;">

#include <stdio.h>
#include <string.h>
#define MAX 100

int main()
{
	char str[MAX];
	char out[MAX];
	fgets(str, MAX, stdin); /* end by \n\0 */
	printf("str is: %s len is: %d\n", str, strlen(str));
	char *start = str;
	char *end;
	end = str + (strlen(str) - 2);
	char *right;
	char *ptr = out;
	char *p;
	right = end;
	printf("%p -> end   %p -> start\n", end, start );
	while((end--) >= start) {
		if (*end == ' ') {
			printf("Find it @: %p\n", end);
			p = end + 1;
			while(p <= right) {
				*ptr++ = *p++;
			}
			right = end - 1;
			*ptr++ = *end;
		} 
	}
	p = right;
	while(p >= start) {
		*ptr++ = *start++;
	}
	*ptr = 0;
	printf("Out: %s\n", out);
	
	return 0;
}

</pre>
<li><h3>第二个版本</h3></li>
<pre class="brush: js;">

#include <stdio.h>
#include <string.h>
#define MAX 1024

int main()
{
	char str[MAX+1];
	char out[MAX+1];
	char *oo = out;
	while (fgets(str, MAX, stdin) != NULL) /* end by \n\0 */
	  {
		/* fgets auto add \n\0 to tail of string */
		printf("str is: %s len is: %d\n", str, strlen(str)); 
		char *p = str + strlen(str) - 1; /* '\n' */
		*p-- = '\0'; /* now \n become  \0' , p pointer the last char*/
		while (p >= str)
		  {
			if (*p == ' ')
			  {
				*p = '\0';
				char *next = p + 1;
				while (*next!= '\0')
					*oo++ = *next++;
				*oo++ = ' ';
			  }
			p--;
		  }
		p = str;
		while (*p != '\0')
			*oo++ = *p++;
		*oo++ = ' ';
		*oo = '\0';
		oo = out;
		printf ("%s\n", oo);
	  }

	return 0;
}
</pre>
<p>&nbsp;&nbsp;函数fgets() 会自动在获得串之后加上'\0\n', 所以操作的时候要非常注意边界问题,开始没注意,只是减去了1,p指向了'\0',结果程序一点输出都没有.</p>
<li><h3>Python 版本的, 是在上班的时候用Python做的，没有用到Pytohn里面的那些函数，可以说这是C格式的Python吧，并没有体现出Python的特性出来，(自己现在也没那个水平去写出那种可以体现出一种语言优点的程序)</h3></li>
<pre class="brush: js;">
#! /usr/bin/python  ## if on ms windows, this is unnecessary.

ostr = input('Enter string: ')
alist = []
out = []

lenght = len (ostr)

for i in range(0, lenght):
	if ostr[i] == ' ':
		alist.append('\0')
	else:
		alist.append(ostr[i])
alist.append('\0')
#print (alist)
		
i = lenght - 1
while (i >= 0):
	if alist[i] == '\0':
		nx = i + 1
		while (alist[nx] != '\0'):
			out.append(alist[nx])
			nx += 1
		out.append(' ')
	i = i -1
i = 0
while (alist[i] != '\0'):
	out.append(alist[i])
	i = i + 1

ooo = ''
for i in out:
	ooo = ooo + i
print (ooo)

</pre>
<li><h3>未完待续</h3></li>
</ul>


  </section>

        <aside id="sidebar">
<a href="../../article/b.c_codes/2014-03-19-Count-appearances-of-digit-whin-given-number.html"  class="button"\> 
            <small>上一篇</small>
          </a>
<a href="../../404.html"  class="button"> 
            <small>下一篇</small>
          </a>

        </aside>
      </div>
    </div>

  
  </body>
</html>
